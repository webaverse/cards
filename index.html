<!doctype html>
<html>
<head>
<style>
  @font-face {
    font-family: 'FuturaLT';
    src: url('/fonts/FuturaLT.woff2');
  }
  @font-face {
    font-family: 'MS-Gothic';
    src: url('/fonts/MS Gothic.ttf');
  }
  @font-face {
    font-family: 'FuturaStd-BoldOblique';
    src: url('/fonts/Futura Std Bold Oblique.otf');
  }
  @font-face {
    font-family: 'GillSans';
    src: url('/fonts/Gill Sans.otf');
  }
  @font-face {
    font-family: 'GillSans-CondensedBold';
    src: url('/fonts/Gill Sans Condensed Bold.ttf');
  }
  @font-face {
    font-family: 'FuturaStd-Heavy';
    src: url('/fonts/Futura Std Heavy.otf');
  }
  @font-face {
    font-family: 'FuturaLT-CondensedLight';
    src: url('/fonts/FuturaLT-CondensedLight.ttf');
  }
  @font-face {
    font-family: 'SanvitoPro-LtCapt';
    src: url('/fonts/SanvitoPro-LtCapt.otf');
  }
  @font-face {
    font-family: 'FuturaLT-Book';
    src: url('/fonts/FuturaLT-Book.ttf');
  }
  #container {
    --size: 300px;
    width: var(--size);
    height: calc(var(--size) / 2.5 * 3.5);
  }
</style>
</head>
<body>
<div id=container></div>
<script type=module>
import procgen, {types} from './procgen.js';

function parseQuery(queryString) {
  var query = {};
  var pairs = (queryString[0] === '?' ? queryString.substr(1) : queryString).split('&');
  for (var i = 0; i < pairs.length; i++) {
    var pair = pairs[i].split('=');
    query[decodeURIComponent(pair[0])] = decodeURIComponent(pair[1] || '');
  }
  return query;
}

(async () => {
const qs = parseQuery(window.location.search);
const tokenId = parseInt(qs.t, 10);

if (!isNaN(tokenId)) {
  const [
    cardSvgSource,
    token,
  ] = await Promise.all([
    (async () => {
      const res = await fetch('/cards.svg');
      const cardSvgSource = await res.text();
      return cardSvgSource;
    })(),
    (async () => {
      const res = await fetch(`https://tokens.webaverse.com/${tokenId}`);
      const token = await res.json();
      return token;
    })(),
  ]);
  console.log('got token', token);
  const {id, name, image, minter: {avatarPreview: minterAvatarPreview}} = token;
  const spec = procgen(id + '')[0];

  const cardWidth = 500;
  const cardHeight = cardWidth/2.5*3.5;

  const svg = document.createElement('svg');
  svg.setAttribute('width', cardWidth);
  svg.setAttribute('height', cardHeight);
  svg.innerHTML = cardSvgSource;

  const container = document.getElementById('container');
  container.appendChild(svg);

  {
    const el = svg;

    const titleTextEl = el.querySelector('#title-text');
    titleTextEl.innerHTML = name;
    for (let i = 0; i < types.length; i++) {
      const type = types[i];
      const typeEl = el.querySelector('#type-' + type);
      typeEl.style.display = type === spec.stats.type ? 'block' : 'none';
    }
    [
      'hp',
      'mp',
      'attack',
      'defense',
      'speed',
      'luck',
    ].forEach(statName => {
      const statEl = el.querySelector('#' + statName);
      const texts = statEl.querySelectorAll('text');
      const textEl = texts[texts.length - 1];
      textEl.innerHTML = spec.stats[statName] + '';
    });
    {
      const imageEl = el.querySelector('#Image image');
      imageEl.setAttribute('xlink:href', image);
    }
    {
      const avatarImageEl = el.querySelector('#avatar-image image');
      avatarImageEl.setAttribute('xlink:href', minterAvatarPreview);
    }
    {
      const stopEls = el.querySelectorAll('#Background linearGradient > stop');
      // const c = `stop-color:${spec.art.colors[0]}`;
      stopEls[1].style.cssText = `stop-color:${spec.art.colors[0]}`;
      stopEls[3].style.cssText = `stop-color:${spec.art.colors[1]}`;
      
      const g = el.querySelector('#Background linearGradient');
      g.id = 'background-' + id;
      const p = g.nextElementSibling;
      p.style = `fill:url(#${g.id});`;
    }
  }
}
})();
</script>
</body>
</html>